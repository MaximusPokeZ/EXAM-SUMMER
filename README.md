# Заславцев Максим М8О-311Б-22
# Билет 32

Билет №32:
1.  Неконтроллируемые ресурсы в Java. Интерфейс Autocloseable. try-with-resources. Метод finalize.
2. 	MongoDB – как устроена и для чего используется. Модель данных в MongoDB. Как производить поиск, вставку и удаления данных из MongoDB. Как в Java работать с MongoDB.
3.  Реализовать endpoint в TaskController, которому при запросе передаётся boostrapServers и название топика. В endpoint создаётся consumer Kafka, который читает топик, начиная с самых старых сообщений. Далее в PostgreSQL находим все строки, которые содержат сообщение Kafka ("test") и возвращаем в endpoint значение с самым большим id из PostgreSQL


## Вопрос №1: Неконтроллируемые ресурсы в Java. Интерфейс Autocloseable. try-with-resources. Метод finalize.
### **Ответ**

В Java есть два типа ресурсов: контролируемые и неконтролируемые.
- Контролируемые - это объекты, которые создаются в куче (например String, List, Map, пользовательские классы). Их жизненный циклом управляет GC, помечает в их OOP(ordinary object pointer в headerе), а потом делает sweep.
- Неконтролируемые - это внешние системные ресурсы: файлы, сетевые соединения, БД-connection и тд в таком роде. Сборщик мусора за это не отвечает, это ложится на плечи программиста. Примеры: FileInputStream, URLConnection.

Интерфейс AutoCloseable - 
Сигнатура:
```java
public interface AutoCloseable {
    void close() throws Exception;
}
```
AutoCloseable - это механизм позволяющий автоматичекси закрывать ресурсы, которые реализуют AutoCloseable. Т.е посл выхода из try все ресурсы автоматически закрываются , даже если произошло исключение. Надо создавать такие объекты внутри try(<--тут-->) {} catch() {} Мы реализуем данный интерфейс (метод close) и тогда сработает он автоматически с помощью try-with-resources.

Метод finalize() (Deprecated) -  является частью класса Object 
Вызывается сборщиком мусора перед удалением объекта. Теоретически может использоваться для освобождения ресурсов. Но нет гарантии, что finalize() будет вызван (например, при быстром завершении программы). Также он замедляет работу GC. Есть риск утечки ресурсов, если метод не вызван. Лучше использовать тогда в finally метод close().

### Пример try-with-resources:
```java
try (FileInputStream f = new FileInputStream("input.txt")) {
    int data;
    while ((data = f.read()) != -1) {
        System.out.print(data);
    }
} catch (IOException e) {
    
}
```

## Вопрос #2. 	MongoDB – как устроена и для чего используется. Модель данных в MongoDB. Как производить поиск, вставку и удаления данных из MongoDB. Как в Java работать с MongoDB.
### **Ответ**

MongoDB — это NoSQL документо-ориентированная база данных , которая хранит данные в виде гибких JSON-подобных документов. Данные хранятся в виде документов BSON (BSON - бинарная версия JSON для сериализации), схема может изменяться динамически. Поддержка репликаций. Оптимизирована для операций записи и чтения больших объемов данных. Иерархия MongoDB: БД -> Коллекции -> Документы. Возможны все операции CRUD. Как я уже писал, Mongo не требует строгой схемы данных, как в postgreSQL например. Поэтому  документы в одной коллекции могут иметь разную структуру. Также возможно шардирование (исп. нескольких серверов). Также как и postgreSQL поддерживает гео данные. Можно создавать индексы для более быстрого поиска. Недостатки: требуется больше памяти, хуже ACID транзакций, чем в РБД, отсутствие строгой типизации, сложна для крупных joinов. eq() — это статический метод из класса com.mongodb.client.model.Filters, который создает фильтр для проверки равенства. Он используется для поиска документов, где значение указанного поля точно соответствует заданному значению.

Доп. типы данных BSON: Date, Timestamp...
Геопространственные типы: Point, LineString, Polygon.

Можно импользовать MongoDB для: динамических схем, json-данные и гео-данные.

### Пример подключения: 
```java
MongoClient client = MongoClients.create("mongodb://localhost:27017");
MongoDatabase database = client.getDatabase("db");
```

### Пример работы:
```java
MongoCollection<Document> collection = database.getCollection("users");

Document doc = new Document("name", "Alice").append("age", 25).append("hobbies", Arrays.asList("reading", "coding"));
collection.insertOne(doc);

collection.find(eq("name", "Alice")).forEach(System.out::println);

collection.updateOne(eq("name", "Alice"), set("age", 26));

collection.deleteOne(eq("name", "Alice"));
```
